# users generic .zshrc file for zsh(1)


## Environment variable configuration
#
# LANG
# http://curiousabt.blog27.fc2.com/blog-entry-65.html
export LANG=ja_JP.UTF-8
export LESSCHARSET=utf-8

# oh-my-zsh export LESS=R
unset LESS

## Backspace key
#
bindkey "^?" backward-delete-char

# ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŒè¡¨ç¤ºã•ã‚Œã‚‹ãŸã³ã«ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ–‡å­—åˆ—ã‚’è©•ä¾¡ã€ç½®æ›ã™ã‚‹
setopt prompt_subst
setopt transient_rprompt

## Default shell configuration
# colors enables us to idenfity color by $fg[red].
autoload colors
colors
case ${UID} in
0)
    PROMPT="ðŸ£  %B%{${fg[red]}%}%/#%{${reset_color}%}%b "
    PROMPT2="ðŸ£  %B%{${fg[red]}%}%_#%{${reset_color}%}%b "
    SPROMPT="%B%{${fg[red]}%}%r is correct? [n,y,a,e]:%{${reset_color}%}%b "
    [ -n "${REMOTEHOST}${SSH_CONNECTION}" ] &&
        PROMPT="ðŸ£  %{${fg[cyan]}%}$(echo ${HOST%%.*} | tr '[a-z]' '[A-Z]') ${PROMPT}"
    ;;
*)
    #
    # Color
    #
    DEFAULT=$'%{\e[1;0m%}'
    RESET="%{${reset_color}%}"
    GREEN="%{${fg[green]}%}"
    BLUE="%{${fg[blue]}%}"
    RED="%{${fg[red]}%}"
    CYAN="%{${fg[cyan]}%}"
    WHITE="%{${fg[white]}%}"
    POH="( ê’ªâŒ“ê’ª) $"

    #
    # Prompt
    #
    PROMPT='ðŸ£  %{$fg_bold[blue]%}${USER}@%m ${RESET}${WHITE}${POH} ${RESET}'
    RPROMPT='${RESET}${WHITE}[${BLUE}%(5~,%-2~/.../%2~,%~)% ${WHITE}]${RESET}'

    #
    # Viå…¥åŠ›ãƒ¢ãƒ¼ãƒ‰ã§PROMPTã®è‰²ã‚’å¤‰ãˆã‚‹
    # http://memo.officebrook.net/20090226.html
    function zle-line-init zle-keymap-select {
      case $KEYMAP in
        vicmd)
        PROMPT="ðŸ£  %{$fg_bold[cyan]%}${USER}@%m ${RESET}${WHITE}${POH} ${RESET}"
        ;;
        main|viins)
        PROMPT="ðŸ£  %{$fg_bold[blue]%}${USER}@%m ${RESET}${WHITE}${POH} ${RESET}"
        ;;
      esac
      zle reset-prompt
    }
    zle -N zle-line-init
    zle -N zle-keymap-select

    # Show git branch when you are in git repository
    # http://d.hatena.ne.jp/mollifier/20100906/p1

    autoload -Uz add-zsh-hook
    autoload -Uz vcs_info

    zstyle ':vcs_info:*' enable git svn hg bzr
    zstyle ':vcs_info:*' formats '(%s)-[%b]'
    zstyle ':vcs_info:*' actionformats '(%s)-[%b|%a]'
    zstyle ':vcs_info:(svn|bzr):*' branchformat '%b:r%r'
    zstyle ':vcs_info:bzr:*' use-simple true

    autoload -Uz is-at-least
    if is-at-least 4.3.10; then
      # ã“ã® check-for-changes ãŒä»Šå›žã®è¨­å®šã™ã‚‹ã¨ã“ã‚
      zstyle ':vcs_info:git:*' check-for-changes true
      zstyle ':vcs_info:git:*' stagedstr "+"    # é©å½“ãªæ–‡å­—åˆ—ã«å¤‰æ›´ã™ã‚‹
      zstyle ':vcs_info:git:*' unstagedstr "-"  # é©å½“ã®æ–‡å­—åˆ—ã«å¤‰æ›´ã™ã‚‹
      zstyle ':vcs_info:git:*' formats '(%s)-[%c%u%b]'
      zstyle ':vcs_info:git:*' actionformats '(%s)-[%c%u%b|%a]'
    fi

    function _update_vcs_info_msg() {
        psvar=()
        LANG=en_US.UTF-8 vcs_info
        psvar[2]=$(_git_not_pushed)
        [[ -n "$vcs_info_msg_0_" ]] && psvar[1]="$vcs_info_msg_0_"
    }
    add-zsh-hook precmd _update_vcs_info_msg

    # show status of git pushed to HEAD in prompt
    function _git_not_pushed()
    {
      if [ "$(git rev-parse --is-inside-work-tree 2>/dev/null)" = "true" ]; then
        head="$(git rev-parse HEAD)"
        for x in $(git rev-parse --remotes)
        do
          if [ "$head" = "$x" ]; then
            return 0
          fi
        done
        echo "|?"
      fi
      return 0
    }

    # git ã®ãƒ–ãƒ©ãƒ³ãƒå *ã¨ä½œæ¥­çŠ¶æ…‹* ã‚’ zsh ã®å³ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã«è¡¨ç¤ºï¼‹ status ã«å¿œã˜ã¦è‰²ã‚‚ã¤ã‘ã¦ã¿ãŸ - Yarukidenized:ãƒ¤ãƒ«ã‚­ãƒ‡ãƒŠã‚¤ã‚ºãƒ‰ :
    # http://d.hatena.ne.jp/uasi/20091025/1256458798
    autoload -Uz VCS_INFO_get_data_git; VCS_INFO_get_data_git 2> /dev/null

    function rprompt-git-current-branch {
      local name st color gitdir action pushed
      if [[ "$PWD" =~ '/\.git(/.*)?$' ]]; then
              return
      fi

      name=`git rev-parse --abbrev-ref=loose HEAD 2> /dev/null`
      if [[ -z $name ]]; then
              return
      fi

      gitdir=`git rev-parse --git-dir 2> /dev/null`
      action=`VCS_INFO_git_getaction "$gitdir"` && action="|$action"
      pushed="`_git_not_pushed`"

      st=`git status 2> /dev/null`
      if [[ -n `echo "$st" | grep "^nothing to"` ]]; then
        color=%F{green}
      elif [[ -n `echo "$st" | grep "^nothing added"` ]]; then
        color=%F{yellow}
      elif [[ -n `echo "$st" | grep "^# Untracked"` ]]; then
        color=%B%F{red}
      else
        color=%F{red}
      fi

      echo "[$color$name$action$pushed%f%b]"
    }

    RPROMPT='`rprompt-git-current-branch`${RESET}${WHITE}[${BLUE}%(5~,%-2~/.../%2~,%~)${WHITE}]${RESET}'

    ;;
esac

# æŒ‡å®šã—ãŸã‚³ãƒžãƒ³ãƒ‰åãŒãªãã€ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåã¨ä¸€è‡´ã—ãŸå ´åˆ cd ã™ã‚‹
setopt auto_cd

# cd ã§Tabã‚’æŠ¼ã™ã¨dir list ã‚’è¡¨ç¤º
setopt auto_pushd

# ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚¹ã‚¿ãƒƒã‚¯ã«åŒã˜ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’è¿½åŠ ã—ãªã„ã‚ˆã†ã«ãªã‚‹
setopt pushd_ignore_dups

# ã‚³ãƒžãƒ³ãƒ‰ã®ã‚¹ãƒšãƒ«ãƒã‚§ãƒƒã‚¯ã‚’ã™ã‚‹
setopt correct

# ã‚³ãƒžãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å…¨ã¦ã®ã‚¹ãƒšãƒ«ãƒã‚§ãƒƒã‚¯ã‚’ã™ã‚‹
setopt correct_all

# ä¸Šæ›¸ããƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã®ç¦æ­¢
setopt no_clobber

# è£œå®Œå€™è£œãƒªã‚¹ãƒˆã‚’è©°ã‚ã¦è¡¨ç¤º
setopt list_packed

# auto_list ã®è£œå®Œå€™è£œä¸€è¦§ã§ã€ls -F ã®ã‚ˆã†ã«ãƒ•ã‚¡ã‚¤ãƒ«ã®ç¨®åˆ¥ã‚’ãƒžãƒ¼ã‚¯è¡¨ç¤º
setopt list_types

# è£œå®Œå€™è£œãŒè¤‡æ•°ã‚ã‚‹æ™‚ã«ã€ä¸€è¦§è¡¨ç¤ºã™ã‚‹
setopt auto_list

# ã‚³ãƒžãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã®å¼•æ•°ã§ --prefix=/usr ãªã©ã® = ä»¥é™ã§ã‚‚è£œå®Œã§ãã‚‹
setopt magic_equal_subst

# ã‚«ãƒƒã‚³ã®å¯¾å¿œãªã©ã‚’è‡ªå‹•çš„ã«è£œå®Œã™ã‚‹
setopt auto_param_keys

# ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåã®è£œå®Œã§æœ«å°¾ã® / ã‚’è‡ªå‹•çš„ã«ä»˜åŠ ã—ã€æ¬¡ã®è£œå®Œã«å‚™ãˆã‚‹
setopt auto_param_slash

# {a-c} ã‚’ a b c ã«å±•é–‹ã™ã‚‹æ©Ÿèƒ½ã‚’ä½¿ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹
setopt brace_ccl

# ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã¯å®Ÿä½“ã‚’è¿½ã†ã‚ˆã†ã«ãªã‚‹
#setopt chase_links

# è£œå®Œã‚­ãƒ¼ï¼ˆTab,  Ctrl+I) ã‚’é€£æ‰“ã™ã‚‹ã ã‘ã§é †ã«è£œå®Œå€™è£œã‚’è‡ªå‹•ã§è£œå®Œã™ã‚‹
setopt auto_menu

# sudoã‚‚è£œå®Œã®å¯¾è±¡
zstyle ':completion:*:sudo:*' command-path /usr/local/sbin /usr/local/bin /usr/sbin /usr/bin /sbin /bin

# è‰²ä»˜ãã§è£œå®Œã™ã‚‹
zstyle ':completion:*' list-colors di=34 fi=0
#zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}

# è¤‡æ•°ã®ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã‚„ãƒ‘ã‚¤ãƒ—ãªã©ã€å¿…è¦ã«å¿œã˜ã¦ tee ã‚„ cat ã®æ©Ÿèƒ½ãŒä½¿ã‚ã‚Œã‚‹
setopt multios

# æœ€å¾ŒãŒãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåã§çµ‚ã‚ã£ã¦ã„ã‚‹å ´åˆæœ«å°¾ã® / ã‚’è‡ªå‹•çš„ã«å–ã‚Šé™¤ã‹ãªã„
setopt noautoremoveslash

# beepã‚’é³´ã‚‰ã•ãªã„ã‚ˆã†ã«ã™ã‚‹
setopt nolistbeep

# Match without pattern
# ex. > rm *~398
# remove * without a file "398". For test, use "echo *~398"
setopt extended_glob

## Keybind configuration
#
# emacs like keybind (e.x. Ctrl-a goes to head of a line and Ctrl-e goes
#   to end of it)
#
bindkey -v

# historical backward/forward search with linehead string binded to ^P/^N
#
autoload history-search-end
zle -N history-beginning-search-backward-end history-search-end
zle -N history-beginning-search-forward-end history-search-end
bindkey "^p" history-beginning-search-backward-end
bindkey "^n" history-beginning-search-forward-end
bindkey "\\ep" history-beginning-search-backward-end
bindkey "\\en" history-beginning-search-forward-end

# glob(*)ã«ã‚ˆã‚‹ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ã‚¿ãƒ«ã‚µãƒ¼ãƒ
bindkey '^R' history-incremental-pattern-search-backward
bindkey '^S' history-incremental-pattern-search-forward

## Command history configuration
HISTFILE=~/.zsh_history
HISTSIZE=10000
SAVEHIST=10000

# ç™»éŒ²æ¸ˆã‚³ãƒžãƒ³ãƒ‰è¡Œã¯å¤ã„æ–¹ã‚’å‰Šé™¤
setopt hist_ignore_all_dups

# historyã®å…±æœ‰
setopt share_history

# ä½™åˆ†ãªç©ºç™½ã¯è©°ã‚ã‚‹
setopt hist_reduce_blanks

# add history when command executed.
setopt inc_append_history

# history (fc -l) ã‚³ãƒžãƒ³ãƒ‰ã‚’ãƒ’ã‚¹ãƒˆãƒªãƒªã‚¹ãƒˆã‹ã‚‰å–ã‚Šé™¤ãã€‚
setopt hist_no_store
# ã‚µã‚¹ãƒšãƒ³ãƒ‰ä¸­ã®ãƒ—ãƒ­ã‚»ã‚¹ã¨åŒã˜ã‚³ãƒžãƒ³ãƒ‰åã‚’å®Ÿè¡Œã—ãŸå ´åˆã¯ãƒªã‚¸ãƒ¥ãƒ¼ãƒ ã™ã‚‹
#setopt auto_resume

# =command ã‚’ command ã®ãƒ‘ã‚¹åã«å±•é–‹ã™ã‚‹
#setopt equals

# ãƒ•ã‚¡ã‚¤ãƒ«åã§ #, ~, ^ ã® 3 æ–‡å­—ã‚’æ­£è¦è¡¨ç¾ã¨ã—ã¦æ‰±ã†
#setopt extended_glob

# zsh ã®é–‹å§‹ãƒ»çµ‚äº†æ™‚åˆ»ã‚’ãƒ’ã‚¹ãƒˆãƒªãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã‚€
#setopt extended_history

# Ctrl+S/Ctrl+Q ã«ã‚ˆã‚‹ãƒ•ãƒ­ãƒ¼åˆ¶å¾¡ã‚’ä½¿ã‚ãªã„ã‚ˆã†ã«ã™ã‚‹
#setopt NO_flow_control

# å„ã‚³ãƒžãƒ³ãƒ‰ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã¨ãã«ãƒ‘ã‚¹ã‚’ãƒãƒƒã‚·ãƒ¥ã«å…¥ã‚Œã‚‹
#setopt hash_cmds

# ã‚³ãƒžãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã®å…ˆé ­ãŒã‚¹ãƒšãƒ¼ã‚¹ã§å§‹ã¾ã‚‹å ´åˆãƒ’ã‚¹ãƒˆãƒªã«è¿½åŠ ã—ãªã„
#setopt hist_ignore_space

# ãƒ’ã‚¹ãƒˆãƒªã‚’å‘¼ã³å‡ºã—ã¦ã‹ã‚‰å®Ÿè¡Œã™ã‚‹é–“ã«ä¸€æ—¦ç·¨é›†ã§ãã‚‹çŠ¶æ…‹ã«ãªã‚‹
#setopt hist_verify

# ã‚·ã‚§ãƒ«ãŒçµ‚äº†ã—ã¦ã‚‚è£ã‚¸ãƒ§ãƒ–ã« HUP ã‚·ã‚°ãƒŠãƒ«ã‚’é€ã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹
#setopt NO_hup

# Ctrl+D ã§ã¯çµ‚äº†ã—ãªã„ã‚ˆã†ã«ãªã‚‹ï¼ˆexit, logout ãªã©ã‚’ä½¿ã†ï¼‰
#setopt ignore_eof

# ã‚³ãƒžãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã§ã‚‚ # ä»¥é™ã‚’ã‚³ãƒ¡ãƒ³ãƒˆã¨è¦‹ãªã™
#setopt interactive_comments

# ãƒ¡ãƒ¼ãƒ«ã‚¹ãƒ—ãƒ¼ãƒ« $MAIL ãŒèª­ã¾ã‚Œã¦ã„ãŸã‚‰ãƒ¯ãƒ¼ãƒ‹ãƒ³ã‚°ã‚’è¡¨ç¤ºã™ã‚‹
#setopt mail_warning

# ãƒ•ã‚¡ã‚¤ãƒ«åã®å±•é–‹ã§ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ãƒžãƒƒãƒã—ãŸå ´åˆæœ«å°¾ã« / ã‚’ä»˜åŠ ã™ã‚‹
#setopt mark_dirs

# ãƒ•ã‚¡ã‚¤ãƒ«åã®å±•é–‹ã§ã€è¾žæ›¸é †ã§ã¯ãªãæ•°å€¤çš„ã«ã‚½ãƒ¼ãƒˆã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚‹
#setopt numeric_glob_sort

# ã‚³ãƒžãƒ³ãƒ‰åã« / ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã¨ã PATH ä¸­ã®ã‚µãƒ–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’æŽ¢ã™
setopt path_dirs

# æˆ»ã‚Šå€¤ãŒ 0 ä»¥å¤–ã®å ´åˆçµ‚äº†ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºã™ã‚‹
# setopt print_exit_value

# pushd ã‚’å¼•æ•°ãªã—ã§å®Ÿè¡Œã—ãŸå ´åˆ pushd $HOME ã¨è¦‹ãªã•ã‚Œã‚‹
#setopt pushd_to_home

# rm * ãªã©ã®éš›ã€æœ¬å½“ã«å…¨ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¶ˆã—ã¦è‰¯ã„ã‹ã®ç¢ºèªã—ãªã„ã‚ˆã†ã«ãªã‚‹
#setopt rm_star_silent

# rm_star_silent ã®é€†ã§ã€10 ç§’é–“åå¿œã—ãªããªã‚Šã€é ­ã‚’å†·ã¾ã™æ™‚é–“ãŒä¸Žãˆã‚‰ã‚Œã‚‹
#setopt rm_star_wait

# for, repeat, select, if, function ãªã©ã§ç°¡ç•¥æ–‡æ³•ãŒä½¿ãˆã‚‹ã‚ˆã†ã«ãªã‚‹
#setopt short_loops

# ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®è¤‡æ•°è¡Œã‚³ãƒžãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ç·¨é›†ã§ã¯ãªãã€ï¼‘è¡Œç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã«ãªã‚‹
#setopt single_line_zle

# ã‚³ãƒžãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ãŒã©ã®ã‚ˆã†ã«å±•é–‹ã•ã‚Œå®Ÿè¡Œã•ã‚ŒãŸã‹ã‚’è¡¨ç¤ºã™ã‚‹ã‚ˆã†ã«ãªã‚‹
#setopt xtrace

# ^ã§cd ..ã™ã‚‹
function cdup() {
echo
cd ..
zle reset-prompt
}
zle -N cdup
# bindkey '\^' cdup

# ctrl-w, ctrl-bã‚­ãƒ¼ã§å˜èªžç§»å‹•
bindkey "^W" forward-word
bindkey "^B" backward-word

# back-wordã§ã®å˜èªžå¢ƒç•Œã®è¨­å®š
autoload -Uz select-word-style
select-word-style default
zstyle ':zle:*' word-chars " _-./;@"
zstyle ':zle:*' word-style unspecified

# URLã‚’ã‚³ãƒ”ãƒšã—ãŸã¨ãã«è‡ªå‹•ã§ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
autoload -Uz url-quote-magic
zle -N self-insert url-quote-magic

# å‹æ‰‹ã«pushd
setopt autopushd

# ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æœ¬æ–‡å‡ºåŠ›ã«è‰²ä»˜ã‘
e_normal=`echo -e "Â¥033[0;30m"`
e_RED=`echo -e "Â¥033[1;31m"`
e_BLUE=`echo -e "Â¥033[1;36m"`

function make() {
    LANG=C command make "$@" 2>&1 | sed -e "s@[Ee]rror:.*@$e_RED&$e_normal@g" -e "s@cannotÂ¥sfind.*@$e_RED&$e_normal@g" -e "s@[Ww]arning:.*@$e_BLUE&$e_normal@g"
}
function cwaf() {
    LANG=C command ./waf "$@" 2>&1 | sed -e "s@[Ee]rror:.*@$e_RED&$e_normal@g" -e "s@cannotÂ¥sfind.*@$e_RED&$e_normal@g" -e "s@[Ww]arning:.*@$e_BLUE&$e_normal@g"
}

## Completion configuration
#
fpath=(~/.zsh/functions/Completion ${fpath})
autoload -U compinit
compinit -u


## zsh editor
#
autoload zed


## Prediction configuration
#
autoload predict-on
#predict-off

## Command Line Stack [Esc]-[q]
bindkey -a 'q' push-line


## Alias configuration
#
# expand aliases before completing
#
setopt complete_aliases     # aliased ls needs if file/dir completions work

alias where="command -v"

case "${OSTYPE}" in
freebsd*|darwin*)
    alias ls="ls -alG"
    zle -N expand-to-home-or-insert
    bindkey "@"  expand-to-home-or-insert
    ;;
linux*)
    alias la="ls -al"
    ;;
esac


case "${OSTYPE}" in
# MacOSX
darwin*)
    export PATH=$PATH:/opt/local/bin:/opt/local/sbin/
    export PATH=$PATH:/System/Library/PrivateFrameworks/Apple80211.framework/Versions/A/Resources/
    ;;
freebsd*)
    case ${UID} in
    0)
        updateports()
        {
            if [ -f /usr/ports/.portsnap.INDEX ]
            then
                portsnap fetch update
            else
                portsnap fetch extract update
            fi
            (cd /usr/ports/; make index)

            portversion -v -l \<
        }
        alias appsupgrade='pkgdb -F && BATCH=YES NO_CHECKSUM=YES portupgrade -a'
        ;;
    esac
    ;;
esac


## terminal configuration
# http://journal.mycom.co.jp/column/zsh/009/index.html
unset LSCOLORS

case "${TERM}" in
xterm)
    export TERM=xterm-color

    ;;
kterm)
    export TERM=kterm-color
    # set BackSpace control character

    stty erase
    ;;

cons25)
    unset LANG
  export LSCOLORS=ExFxCxdxBxegedabagacad

    export LS_COLORS='di=01;32:ln=01;35:so=01;32:ex=01;31:bd=46;34:cd=43;34:su=41;30:sg=46;30'
    zstyle ':completion:*' list-colors \
        'di=;36;1' 'ln=;35;1' 'so=;32;1' 'ex=31;1' 'bd=46;34' 'cd=43;34'
    ;;

kterm*|xterm*)
   # Terminal.app
#    precmd() {
#        echo -ne "\033]0;${USER}@${HOST%%.*}:${PWD}\007"
#    }
    # export LSCOLORS=exfxcxdxbxegedabagacad
    # export LSCOLORS=gxfxcxdxbxegedabagacad
    # export LS_COLORS='di=1;34:ln=35:so=32:pi=33:ex=31:bd=46;34:cd=43;34:su=41;30:sg=46;30'

    export CLICOLOR=1
    export LSCOLORS=ExFxCxDxBxegedabagacad

    zstyle ':completion:*' list-colors \
        'di=36' 'ln=35' 'so=32' 'ex=31' 'bd=46;34' 'cd=43;34'
    ;;

dumb)
    echo "Welcome Emacs Shell"
    ;;
esac



export EDITOR=vim
export PATH=$PATH:$HOME/local/bin:/usr/local/git/bin
export PATH=$PATH:$HOME/dotfiles/bin
export PATH=$PATH:$HOME/bin
export PATH=$PATH:/sbin:/usr/local/bin
export MANPATH=$MANPATH:/opt/local/man:/usr/local/share/man

expand-to-home-or-insert () {
        if [ "$LBUFFER" = "" -o "$LBUFFER[-1]" = " " ]; then
                LBUFFER+="~/"
        else
                zle self-insert
        fi
}

# C-M-h ã§ãƒãƒ¼ãƒˆã‚·ãƒ¼ãƒˆã‚’è¡¨ç¤ºã™ã‚‹
cheat-sheet () { zle -M "`cat ~/dotfiles/.zsh/cheat-sheet`" }
zle -N cheat-sheet
# bindkey "^[^h" cheat-sheet

# zsh ã® exntended_glob ã¨ HEAD^^^ ã‚’å…±å­˜ã•ã›ã‚‹ã€‚
# http://subtech.g.hatena.ne.jp/cho45/20080617/1213629154
typeset -A abbreviations
abbreviations=(
  "L"    "| $PAGER"
  "G"    "| grep"

  "HEAD^"     "HEAD\\^"
  "HEAD^^"    "HEAD\\^\\^"
  "HEAD^^^"   "HEAD\\^\\^\\^"
  "HEAD^^^^"  "HEAD\\^\\^\\^\\^\\^"
  "HEAD^^^^^" "HEAD\\^\\^\\^\\^\\^"
)

magic-abbrev-expand () {
  local MATCH
  LBUFFER=${LBUFFER%%(#m)[-_a-zA-Z0-9^]#}
  LBUFFER+=${abbreviations[$MATCH]:-$MATCH}
}

magic-abbrev-expand-and-insert () {
  magic-abbrev-expand
  zle self-insert
}

magic-abbrev-expand-and-accept () {
  magic-abbrev-expand
  zle accept-line
}

no-magic-abbrev-expand () {
  LBUFFER+=' '
}

zle -N magic-abbrev-expand
zle -N magic-abbrev-expand-and-insert
zle -N magic-abbrev-expand-and-accept
zle -N no-magic-abbrev-expand
bindkey "\r"  magic-abbrev-expand-and-accept # M-x RET ã¯ã§ããªããªã‚‹
bindkey "^J"  accept-line # no magic
bindkey " "   magic-abbrev-expand-and-insert
bindkey "."   magic-abbrev-expand-and-insert
bindkey "^x " no-magic-abbrev-expand

# Incremental completion on zsh
# http://mimosa-pudica.net/src/incr-0.2.zsh
# ã‚„ã£ã±ã‚Šauto_menuä½¿ã„ãŸã„ã®ã§off
# source ~/.zsh/incr*.zsh

# auto-fuã®è¨­å®šã€‚^Pã¨ã‹ã®Historyæ¤œç´¢ã¨ç›¸æ€§ãŒæ‚ªã„ã®ã§ã²ã¨ã¾ãšç„¡åŠ¹ã«ã€‚
# http://d.hatena.ne.jp/tarao/20100531/1275322620
# incremental completion
# if is-at-least 4.3.10; then
    # function () { # precompile
        # local A
        # A=~/.zsh/auto-fu.zsh/auto-fu.zsh
        # [[ -e "${A:r}.zwc" ]] && [[ "$A" -ot "${A:r}.zwc" ]] ||
        # zsh -c "source $A; auto-fu-zcompile $A ${A:h}" >/dev/null 2>&1
    # }
    # source ~/.zsh/auto-fu.zsh/auto-fu; auto-fu-install
    # function zle-line-init () { auto-fu-init }
    # zle -N zle-line-init
    # zstyle ':auto-fu:highlight' input bold
    # zstyle ':auto-fu:highlight' completion fg=white
    # zstyle ':auto-fu:var' postdisplay ''
    # function afu+cancel () {
        # afu-clearing-maybe
        # ((afu_in_p == 1)) && { afu_in_p=0; BUFFER="$buffer_cur"; }
    # }
    # function bindkey-advice-before () {
        # local key="$1"
        # local advice="$2"
        # local widget="$3"
        # [[ -z "$widget" ]] && {
            # local -a bind
            # bind=(`bindkey -M main "$key"`)
            # widget=$bind[2]
        # }
        # local fun="$advice"
        # if [[ "$widget" != "undefined-key" ]]; then
            # local code=${"$(<=(cat <<"EOT"
                # function $advice-$widget () {
                    # zle $advice
                    # zle $widget
                # }
                # fun="$advice-$widget"
# EOT
            # ))"}
            # eval "${${${code//\$widget/$widget}//\$key/$key}//\$advice/$advice}"
        # fi
        # zle -N "$fun"
        # bindkey -M afu "$key" "$fun"
    # }
    # bindkey-advice-before "^G" afu+cancel
    # bindkey-advice-before "^[" afu+cancel
    # bindkey-advice-before "^J" afu+cancel afu+accept-line

    # # delete unambiguous prefix when accepting line
    # function afu+delete-unambiguous-prefix () {
        # afu-clearing-maybe
        # local buf; buf="$BUFFER"
        # local bufc; bufc="$buffer_cur"
        # [[ -z "$cursor_new" ]] && cursor_new=-1
        # [[ "$buf[$cursor_new]" == ' ' ]] && return
        # [[ "$buf[$cursor_new]" == '/' ]] && return
        # ((afu_in_p == 1)) && [[ "$buf" != "$bufc" ]] && {
            # # there are more than one completion candidates
            # zle afu+complete-word
            # [[ "$buf" == "$BUFFER" ]] && {
                # # the completion suffix was an unambiguous prefix
                # afu_in_p=0; buf="$bufc"
            # }
            # BUFFER="$buf"
            # buffer_cur="$bufc"
        # }
    # }
    # zle -N afu+delete-unambiguous-prefix
    # function afu-ad-delete-unambiguous-prefix () {
        # local afufun="$1"
        # local code; code=$functions[$afufun]
        # eval "function $afufun () { zle afu+delete-unambiguous-prefix; $code }"
    # }
    # afu-ad-delete-unambiguous-prefix afu+accept-line
    # afu-ad-delete-unambiguous-prefix afu+accept-line-and-down-history
    # afu-ad-delete-unambiguous-prefix afu+accept-and-hold
# fi


function rmf(){
   for file in $*
   do
      __rm_single_file $file
   done
}

function __rm_single_file(){
       if ! [ -d ~/.Trash/ ]
       then
               command /bin/mkdir ~/.Trash
       fi

       if ! [ $# -eq 1 ]
       then
               echo "__rm_single_file: 1 argument required but $# passed."
               exit
       fi

       if [ -e $1 ]
       then
               BASENAME=`basename $1`
               NAME=$BASENAME
               COUNT=0
               while [ -e ~/.Trash/$NAME ]
               do
                       COUNT=$(($COUNT+1))
                       NAME="$BASENAME.$COUNT"
               done

               command /bin/mv $1 ~/.Trash/$NAME
       else
               echo "No such file or directory: $file"
       fi
}

## aliasè¨­å®š
#
[ -f ~/dotfiles/.zshrc.alias ] && source ~/dotfiles/.zshrc.alias

case "${OSTYPE}" in
# MacOSX
darwin*)
    # ã“ã“ã«è¨­å®š
    [ -f ~/dotfiles/.zshrc.osx ] && source ~/dotfiles/.zshrc.osx
    ;;
# Linux
linux*)
    # ã“ã“ã«è¨­å®š
    [ -f ~/dotfiles/.zshrc.linux ] && source ~/dotfiles/.zshrc.linux
    ;;
esac


# ~/.zshrc
# setting for percol
source ~/.zsh/percol.zsh

## localå›ºæœ‰è¨­å®š
#
[ -f ~/.zshrc.local ] && source ~/.zshrc.local

